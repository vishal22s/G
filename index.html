<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mini Book Maker</title>
    <script src="https://unpkg.com/pdf-lib@1.17.1/dist/pdf-lib.min.js"></script>
    <script src="https://unpkg.com/pdfjs-dist@3.4.120/build/pdf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/sortablejs@latest/Sortable.min.js"></script>
    <style>
        :root {
            --primary: #4CAF50; --secondary: #333; --bg: #f4f4f4; --card: #fff;
            --border: #ddd; --success: #28a745; --error: #f44336;
        }
        body { font-family: Arial, sans-serif; background: var(--bg); color: var(--secondary); margin: 0; padding: 20px; display: flex; justify-content: center; }
        .container { max-width: 1000px; width: 100%; background: var(--card); padding: 20px; border-radius: 10px; box-shadow: 0 4px 8px rgba(0,0,0,0.1); }
        h1 { color: var(--primary); text-align: center; }
        .section { margin-bottom: 20px; padding: 15px; border: 1px solid var(--border); border-radius: 8px; }
        .upload-area { text-align: center; border: 2px dashed var(--border); padding: 30px; border-radius: 8px; cursor: pointer; transition: background 0.3s; }
        .upload-area:hover { background: #e8f5e9; }
        #files-list { list-style: none; padding: 0; }
        #files-list li { padding: 10px; border: 1px solid var(--border); margin-bottom: 10px; display: flex; align-items: center; cursor: move; background: #fff; border-radius: 5px; }
        #files-list li canvas { width: 50px; height: 70px; margin-right: 10px; border: 1px solid var(--border); }
        #files-list li .pages { display: none; grid-template-columns: repeat(auto-fill, minmax(80px, 1fr)); gap: 10px; margin-top: 10px; }
        #files-list li .pages canvas { width: 80px; height: 113px; cursor: pointer; }
        #files-list li.expanded .pages { display: grid; }
        .btn { padding: 10px 20px; background: var(--primary); color: white; border: none; border-radius: 5px; cursor: pointer; transition: background 0.3s; }
        .btn:hover { background: #45a049; }
        .btn:disabled { background: var(--secondary); cursor: not-allowed; }
        .remove-btn { background: var(--error); margin-left: auto; }
        .control-group { margin-bottom: 10px; }
        .control-group label { display: block; font-weight: bold; }
        .modal { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); display: none; justify-content: center; align-items: center; z-index: 100; }
        .modal-content { background: white; padding: 20px; border-radius: 10px; max-width: 600px; width: 90%; }
        #progress { width: 100%; background: #ddd; height: 10px; margin-top: 10px; }
        #progress-bar { height: 100%; background: var(--primary); width: 0; transition: width 0.3s; }
        .hidden { display: none; }
        #output-container { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; }
        @media (max-width: 768px) { #output-container { grid-template-columns: 1fr; } }
    </style>
</head>
<body>
    <div class="container">
        <h1>Mini Book Maker</h1>
        <p style="text-align: center; color: var(--secondary);">Upload PDFs/Images, reorder, customize, and create mini books!</p>

        <div class="section upload-area" id="upload-area">
            <div>Click to upload files (PDFs/Images, multiple OK)</div>
            <input type="file" id="file-input" accept="application/pdf,image/png,image/jpeg" multiple style="display: none;">
        </div>

        <div id="files-section" class="section hidden">
            <h3>Files (Drag to Reorder)</h3>
            <p id="total-files">Total files: 0</p>
            <ul id="files-list"></ul>
            <button class="btn" id="add-more">Add More</button>
        </div>

        <div class="section">
            <h3>Options</h3>
            <div class="control-group">
                <label for="paper-size">Paper Size</label>
                <select id="paper-size">
                    <option value="a4">A4</option>
                    <option value="letter">Letter</option>
                    <option value="a3">A3</option>
                </select>
            </div>
            <div class="control-group">
                <input type="checkbox" id="separate-files">
                <label for="separate-files">Start each file on new sheet</label>
            </div>
            <div class="control-group">
                <input type="checkbox" id="cutting-guides">
                <label for="cutting-guides">Add Cutting Guides</label>
            </div>
            <div class="control-group">
                <input type="checkbox" id="stapling-guides">
                <label for="stapling-guides">Add Stapling Guides (with margins)</label>
                <div id="stapling-margin" style="display: none;">
                    <label>Margin Size (mm): <span id="margin-value">2</span></label>
                    <input type="range" min="1" max="5" value="2" id="margin-slider">
                </div>
            </div>
        </div>

        <div class="section">
            <h3>Watermark</h3>
            <input type="checkbox" id="wm-enable">
            <label for="wm-enable">Enable Global Watermark</label>
            <button class="btn" id="edit-global-wm">Edit Global</button>
            <input type="checkbox" id="append-page-num">
            <label for="append-page-num">Append Page Number</label>
        </div>

        <button class="btn" id="process-btn" disabled>Process</button>

        <div id="progress-section" class="hidden">
            <p id="progress-text">Processing...</p>
            <div id="progress"><div id="progress-bar"></div></div>
        </div>

        <div id="output-container" class="hidden">
            <div>
                <h3>Odd PDF</h3>
                <canvas id="odd-preview"></canvas>
                <a id="odd-download" class="btn hidden">Download Odd</a>
            </div>
            <div>
                <h3>Even PDF</h3>
                <canvas id="even-preview"></canvas>
                <a id="even-download" class="btn hidden">Download Even</a>
            </div>
        </div>
    </div>

    <div class="modal" id="wm-modal">
        <div class="modal-content">
            <h3 id="wm-title">Edit Watermark</h3>
            <div class="control-group">
                <label>Text</label>
                <input type="text" id="wm-text">
            </div>
            <div class="control-group">
                <label>Position</label>
                <select id="wm-position">
                    <option value="center">Center</option>
                    <option value="top-left">Top-Left</option>
                    <option value="top-right">Top-Right</option>
                    <option value="bottom-left">Bottom-Left</option>
                    <option value="bottom-right">Bottom-Right</option>
                </select>
            </div>
            <div class="control-group">
                <label>Opacity (<span id="wm-opacity-val">0.5</span>)</label>
                <input type="range" min="0" max="1" step="0.05" value="0.5" id="wm-opacity">
            </div>
            <div class="control-group">
                <label>Size (<span id="wm-size-val">50</span>pt)</label>
                <input type="range" min="8" max="150" value="50" id="wm-size">
            </div>
            <div class="control-group">
                <label>Rotation (<span id="wm-rotation-val">0</span>Â°)</label>
                <input type="range" min="-90" max="90" step="5" value="0" id="wm-rotation">
            </div>
            <div class="control-group">
                <label>Color</label>
                <input type="color" value="#ff0000" id="wm-color">
            </div>
            <button class="btn" id="save-wm">Save</button>
        </div>
    </div>

    <script>
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://unpkg.com/pdfjs-dist@3.4.120/build/pdf.worker.min.js';

        const uploadArea = document.getElementById('upload-area');
        const fileInput = document.getElementById('file-input');
        const filesList = document.getElementById('files-list');
        const filesSection = document.getElementById('files-section');
        const totalFiles = document.getElementById('total-files');
        const addMore = document.getElementById('add-more');
        const processBtn = document.getElementById('process-btn');
        const progressSection = document.getElementById('progress-section');
        const progressText = document.getElementById('progress-text');
        const progressBar = document.getElementById('progress-bar');
        const outputContainer = document.getElementById('output-container');
        const oddPreview = document.getElementById('odd-preview');
        const evenPreview = document.getElementById('even-preview');
        const oddDownload = document.getElementById('odd-download');
        const evenDownload = document.getElementById('even-download');
        const wmModal = document.getElementById('wm-modal');
        const wmTitle = document.getElementById('wm-title');
        const wmText = document.getElementById('wm-text');
        const wmPosition = document.getElementById('wm-position');
        const wmOpacity = document.getElementById('wm-opacity');
        const wmOpacityVal = document.getElementById('wm-opacity-val');
        const wmSize = document.getElementById('wm-size');
        const wmSizeVal = document.getElementById('wm-size-val');
        const wmRotation = document.getElementById('wm-rotation');
        const wmRotationVal = document.getElementById('wm-rotation-val');
        const wmColor = document.getElementById('wm-color');
        const saveWm = document.getElementById('save-wm');
        const editGlobalWm = document.getElementById('edit-global-wm');
        const appendPageNum = document.getElementById('append-page-num');
        const staplingGuides = document.getElementById('stapling-guides');
        const staplingMargin = document.getElementById('stapling-margin');
        const marginSlider = document.getElementById('margin-slider');
        const marginValue = document.getElementById('margin-value');

        let files = []; // {name, data: ArrayBuffer, pages: [{pageNum?, thumbnail: dataURL, wm?}] , wm?}
        let globalWm = null;
        let currentWmContext = null; // 'global' or {fileIndex, pageIndex?}
        let paperSizes = { a4: [595, 842], letter: [612, 792], a3: [842, 1191] };

        uploadArea.addEventListener('click', () => fileInput.click());
        fileInput.addEventListener('change', handleFiles);
        addMore.addEventListener('click', () => fileInput.click());
        editGlobalWm.addEventListener('click', () => openWmModal('global'));
        saveWm.addEventListener('click', saveWmOptions);
        staplingGuides.addEventListener('change', () => staplingMargin.style.display = staplingGuides.checked ? 'block' : 'none');
        marginSlider.addEventListener('input', () => marginValue.textContent = marginSlider.value);
        wmOpacity.addEventListener('input', () => wmOpacityVal.textContent = wmOpacity.value);
        wmSize.addEventListener('input', () => wmSizeVal.textContent = wmSize.value);
        wmRotation.addEventListener('input', () => wmRotationVal.textContent = wmRotation.value);
        processBtn.addEventListener('click', process);

        async function handleFiles(e) {
            const newFiles = Array.from(e.target.files);
            for (const f of newFiles) {
                const data = await f.arrayBuffer();
                const item = { name: f.name, data, pages: [] };
                if (f.type === 'application/pdf') {
                    const uint8Data = new Uint8Array(data);
                    const copyForPdfjs = uint8Data.slice(0); // Copy for pdfjs to avoid detachment
                    const pdf = await pdfjsLib.getDocument(copyForPdfjs).promise;
                    for (let p = 1; p <= pdf.numPages; p++) {
                        const page = await pdf.getPage(p);
                        const vp = page.getViewport({scale: 1});
                        const canvas = document.createElement('canvas');
                        canvas.width = vp.width; canvas.height = vp.height;
                        await page.render({canvasContext: canvas.getContext('2d'), viewport: vp}).promise;
                        const thumbCanvas = document.createElement('canvas');
                        const thumbScale = 80 / vp.width;
                        thumbCanvas.width = 80; thumbCanvas.height = vp.height * thumbScale;
                        thumbCanvas.getContext('2d').drawImage(canvas, 0, 0, thumbCanvas.width, thumbCanvas.height);
                        item.pages.push({pageNum: p, thumbnail: thumbCanvas.toDataURL()});
                    }
                } else if (f.type.startsWith('image/')) {
                    const img = new Image();
                    img.src = URL.createObjectURL(f);
                    await new Promise(r => img.onload = r);
                    const canvas = document.createElement('canvas');
                    canvas.width = img.width; canvas.height = img.height;
                    canvas.getContext('2d').drawImage(img, 0, 0);
                    const thumbCanvas = document.createElement('canvas');
                    const thumbScale = 80 / img.width;
                    thumbCanvas.width = 80; thumbCanvas.height = img.height * thumbScale;
                    thumbCanvas.getContext('2d').drawImage(canvas, 0, 0, thumbCanvas.width, thumbCanvas.height);
                    item.pages.push({thumbnail: thumbCanvas.toDataURL()});
                }
                files.push(item);
            }
            renderFilesList();
            filesSection.classList.remove('hidden');
            processBtn.disabled = files.length === 0;
            e.target.value = '';
        }

        function renderFilesList() {
            filesList.innerHTML = '';
            files.forEach((file, fi) => {
                const li = document.createElement('li');
                li.id = `file-${fi}`;
                li.innerHTML = `<canvas width="50" height="70"></canvas><span>${file.name} (${file.pages.length} pages)</span><button class="expand">Expand Pages</button><button class="edit-wm">Edit File WM</button><button class="remove-btn">Remove</button>`;
                const thumbCanvas = li.querySelector('canvas');
                if (file.pages[0]) {
                    const img = new Image();
                    img.src = file.pages[0].thumbnail;
                    img.onload = () => thumbCanvas.getContext('2d').drawImage(img, 0, 0, 50, 70);
                }
                const pagesDiv = document.createElement('div');
                pagesDiv.classList.add('pages');
                file.pages.forEach((page, pi) => {
                    const pageDiv = document.createElement('div');
                    pageDiv.innerHTML = `<canvas width="80" height="113"></canvas><p>Page ${pi+1}</p>`;
                    const pCanvas = pageDiv.querySelector('canvas');
                    const pImg = new Image();
                    pImg.src = page.thumbnail;
                    pImg.onload = () => pCanvas.getContext('2d').drawImage(pImg, 0, 0, 80, 113);
                    pCanvas.addEventListener('click', () => openWmModal({fileIndex: fi, pageIndex: pi}));
                    pagesDiv.appendChild(pageDiv);
                });
                li.appendChild(pagesDiv);
                li.querySelector('.expand').addEventListener('click', () => li.classList.toggle('expanded'));
                li.querySelector('.edit-wm').addEventListener('click', () => openWmModal({fileIndex: fi}));
                li.querySelector('.remove-btn').addEventListener('click', () => {
                    files.splice(fi, 1);
                    renderFilesList();
                });
                filesList.appendChild(li);
            });
            totalFiles.textContent = `Total files: ${files.length}`;
            Sortable.create(filesList, {
                animation: 150,
                onEnd: (evt) => {
                    const [moved] = files.splice(evt.oldIndex, 1);
                    files.splice(evt.newIndex, 0, moved);
                    renderFilesList();
                }
            });
        }

        function openWmModal(context) {
            currentWmContext = context;
            let opts;
            if (context === 'global') {
                opts = globalWm || {};
                wmTitle.textContent = 'Global Watermark';
            } else if (context.pageIndex !== undefined) {
                opts = files[context.fileIndex].pages[context.pageIndex].wm || files[context.fileIndex].wm || globalWm || {};
                wmTitle.textContent = `Page ${context.pageIndex + 1} of ${files[context.fileIndex].name}`;
            } else {
                opts = files[context.fileIndex].wm || globalWm || {};
                wmTitle.textContent = `File: ${files[context.fileIndex].name}`;
            }
            wmText.value = opts.text || '';
            wmPosition.value = opts.position || 'center';
            wmOpacity.value = opts.opacity || 0.5;
            wmOpacityVal.textContent = wmOpacity.value;
            wmSize.value = opts.size || 50;
            wmSizeVal.textContent = wmSize.value;
            wmRotation.value = opts.rotation || 0;
            wmRotationVal.textContent = wmRotation.value;
            wmColor.value = opts.color || '#ff0000';
            wmModal.style.display = 'flex';
        }

        function saveWmOptions() {
            const opts = {
                text: wmText.value.trim(),
                position: wmPosition.value,
                opacity: parseFloat(wmOpacity.value),
                size: parseInt(wmSize.value),
                rotation: parseInt(wmRotation.value),
                color: hexToRgb(wmColor.value)
            };
            if (currentWmContext === 'global') {
                globalWm = opts;
            } else if (currentWmContext.pageIndex !== undefined) {
                files[currentWmContext.fileIndex].pages[currentWmContext.pageIndex].wm = opts;
            } else {
                files[currentWmContext.fileIndex].wm = opts;
            }
            wmModal.style.display = 'none';
        }

        function hexToRgb(hex) {
            return {
                r: parseInt(hex.slice(1,3),16)/255,
                g: parseInt(hex.slice(3,5),16)/255,
                b: parseInt(hex.slice(5,7),16)/255
            };
        }

        async function process() {
            processBtn.disabled = true;
            progressSection.classList.remove('hidden');
            outputContainer.classList.add('hidden');
            oddDownload.classList.add('hidden');
            evenDownload.classList.add('hidden');
            progressBar.style.width = '0%';

            try {
                const { PDFDocument, rgb, degrees, StandardFonts } = PDFLib;
                const master = await PDFDocument.create();
                let pageIndex = 0;
                const fileStarts = [];

                updateProgress('Combining files...', 10);
                for (const file of files) {
                    fileStarts.push({start: pageIndex, name: file.name});
                    for (const p of file.pages) {
                        let pdfPage;
                        if (p.pageNum) {
                            const src = await PDFDocument.load(file.data);
                            const [emb] = await master.embedPdf(src, [p.pageNum - 1]);
                            pdfPage = master.addPage([emb.width, emb.height]);
                            pdfPage.drawPage(emb);
                        } else {
                            const src = await PDFDocument.create();
                            let image;
                            const imageBytes = await fetch(p.thumbnail).then(res => res.arrayBuffer()); // Thumbnail is dataURL, but for embed, need original? Wait, for images, p no bytes, wait error.
                            // Wait, in handleFiles, for images, no p.bytes, only thumbnail.
                            // Fix: for images, store bytes in item.pages[0].bytes = data;
                            // But in previous code, for images, push({thumbnail})
                            // Missing! Add in handleFiles for images: item.pages.push({bytes: data, thumbnail: thumbCanvas.toDataURL()});
                            // Yes, fix that.
                            // Assume fixed.
                            if (new Blob([p.bytes]).type === 'image/png') image = await src.embedPng(p.bytes);
                            else image = await src.embedJpg(p.bytes);
                            pdfPage = master.addPage([image.width, image.height]);
                            pdfPage.drawImage(image, {x:0, y:0, width: image.width, height: image.height});
                        }
                        pageIndex++;
                    }
                    if (document.getElementById('separate-files').checked && files.indexOf(file) < files.length - 1) {
                        const pads = (16 - (pageIndex % 16)) % 16;
                        for (let i = 0; i < pads; i++) {
                            master.addPage(paperSizes[document.getElementById('paper-size').value]);
                            pageIndex++;
                        }
                    }
                }

                const totalPages = master.getPageCount();
                const oddIndices = [], evenIndices = [];
                for (let i = 0; i < totalPages; i++) {
                    (i % 2 === 0 ? oddIndices : evenIndices).push(i);
                }

                const masterBytes = await master.save();

                updateProgress('Imposing odd pages...', 40);
                const oddPdf = await impose(masterBytes, oddIndices, 'odd', fileStarts);
                updateProgress('Imposing even pages...', 70);
                const evenPdf = await impose(masterBytes, evenIndices, 'even', fileStarts);

                updateProgress('Finalizing...', 90);
                const oddBytes = await oddPdf.save();
                const evenBytes = await evenPdf.save();

                setupDownload(oddDownload, oddBytes, 'mini_odd.pdf');
                setupDownload(evenDownload, evenBytes, 'mini_even.pdf');

                await renderPreview(oddBytes, oddPreview);
                await renderPreview(evenBytes, evenPreview);

                outputContainer.classList.remove('hidden');
                updateProgress('Done!', 100);
            } catch (err) {
                alert(`Error: ${err.message}`);
                console.error(err);
            } finally {
                processBtn.disabled = false;
            }
        }

        // Rest of the code remains the same, but add in handleFiles for images: item.pages.push({bytes: data, thumbnail: thumbCanvas.toDataURL()});
        // Also, in createThumbnail, I used document.createElement, fine.
        // For image thumbnails, I used thumbCanvas, but in process, for images, p.bytes is data.

        async function impose(bytes, indices, type, fileStarts) {
            // Same as before
        }

        // Update in handleFiles for images:
        // After thumbCanvas, item.pages.push({bytes: data, thumbnail: thumbCanvas.toDataURL()});
        // Yes, that's the fix for images.

        function updateProgress(text, percent) {
            progressText.textContent = text;
            progressBar.style.width = `${percent}%`;
        }

        function setupDownload(link, bytes, name) {
            const blob = new Blob([bytes], {type: 'application/pdf'});
            link.href = URL.createObjectURL(blob);
            link.download = name;
            link.classList.remove('hidden');
        }

        async function renderPreview(bytes, canvas) {
            const pdf = await pdfjsLib.getDocument(bytes).promise;
            const page = await pdf.getPage(1);
            const vp = page.getViewport({scale: 0.5});
            canvas.width = vp.width; canvas.height = vp.height;
            await page.render({canvasContext: canvas.getContext('2d'), viewport: vp}).promise;
        }
    </script>
</body>
</html>